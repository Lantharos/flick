"use strict";
// Interpreter for Flick language
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Interpreter = void 0;
const readline = __importStar(require("node:readline"));
const plugin_js_1 = require("./plugin.js");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
class Interpreter {
    globalEnv;
    groups = new Map();
    blueprints = new Map();
    output = [];
    pluginManager;
    programAST = null;
    currentFilePath = '';
    loadedModules = new Map();
    constructor(pluginManager, filePath) {
        this.globalEnv = { vars: new Map() };
        this.pluginManager = pluginManager;
        this.currentFilePath = filePath || '';
        // Add built-in functions
        this.globalEnv.vars.set('num', {
            value: (val) => {
                const parsed = parseFloat(val);
                return isNaN(parsed) ? 0 : parsed;
            },
            mutable: false
        });
        this.globalEnv.vars.set('str', {
            value: (val) => String(val),
            mutable: false
        });
        // Add JSON object for parsing and stringifying
        this.globalEnv.vars.set('JSON', {
            value: {
                stringify: async (val, space) => JSON.stringify(val, null, space),
                parse: async (str) => JSON.parse(str),
            },
            mutable: false
        });
    }
    async interpret(ast) {
        this.programAST = ast;
        // Store references for plugins
        this.globalEnv.__interpreter = this;
        this.globalEnv.__program = ast;
        for (const statement of ast.body) {
            await this.evaluateStatement(statement, this.globalEnv);
        }
        // Run plugin completion hooks
        const context = {
            declaredPlugins: this.pluginManager.getDeclaredPlugins(),
            env: this.globalEnv
        };
        await this.pluginManager.runFileCompleteHooks(context);
    }
    getOutput() {
        return this.output;
    }
    async evaluateStatement(node, env) {
        switch (node.type) {
            case 'Program':
                for (const statement of node.body) {
                    await this.evaluateStatement(statement, env);
                }
                return null;
            case 'DeclareStatement':
                return this.handleDeclare(node, env);
            case 'UseStatement':
                return await this.handleUse(node, env);
            case 'ImportStatement':
                return await this.handleImport(node, env);
            case 'RouteStatement':
                return this.handleRoute(node, env);
            case 'RespondStatement':
                return this.handleRespond(node, env);
            case 'GroupDeclaration':
                return this.defineGroup(node, env);
            case 'BlueprintDeclaration':
                return this.defineBlueprint(node, env);
            case 'DoImplementation':
                return this.implementBlueprint(node, env);
            case 'TaskDeclaration':
                return this.defineTask(node, env);
            case 'VariableDeclaration':
                return this.declareVariable(node, env);
            case 'Assignment':
                return this.assignVariable(node, env);
            case 'PrintStatement':
                return await this.executePrint(node, env);
            case 'IfStatement':
                return await this.executeIf(node, env);
            case 'EachLoop':
                return await this.executeEachLoop(node, env);
            case 'MarchLoop':
                return await this.executeMarchLoop(node, env);
            case 'SelectStatement':
                return await this.executeSelect(node, env);
            case 'ExpressionStatement':
                // If the expression is a MemberExpression (like player.greet), treat it as a call
                if (node.expression.type === 'MemberExpression') {
                    const obj = await this.evaluateExpression(node.expression.object, env);
                    const prop = node.expression.computed
                        ? await this.evaluateExpression(node.expression.property, env)
                        : node.expression.property.name;
                    const method = obj[prop];
                    if (typeof method === 'function') {
                        return await method();
                    }
                    return method;
                }
                return await this.evaluateExpression(node.expression, env);
            default:
                throw new Error(`Unknown statement type: ${node.type}`);
        }
    }
    async evaluateExpression(node, env) {
        switch (node.type) {
            case 'Literal':
                return node.value;
            case 'Identifier':
                return this.lookupVariable(node.name, env);
            case 'BinaryExpression':
                return await this.evaluateBinaryExpression(node, env);
            case 'UnaryExpression':
                return await this.evaluateUnaryExpression(node, env);
            case 'CallExpression':
                return await this.evaluateCall(node, env);
            case 'MemberExpression':
                return await this.evaluateMemberExpression(node, env);
            case 'ArrayLiteral':
                const elements = [];
                for (const elem of node.elements) {
                    elements.push(await this.evaluateExpression(elem, env));
                }
                return elements;
            case 'ObjectLiteral':
                const obj = {};
                for (const prop of node.properties) {
                    obj[prop.key] = await this.evaluateExpression(prop.value, env);
                }
                return obj;
            case 'AskExpression':
                return await this.evaluateAsk(node, env);
            default:
                throw new Error(`Unknown statement type: ${node.type}`);
        }
    }
    async handleImport(node, env) {
        try {
            let modulePath = node.from;
            // If it's a relative path, resolve it relative to current file
            if (modulePath.startsWith('.')) {
                const baseDir = (0, node_path_1.dirname)(this.currentFilePath);
                modulePath = (0, node_path_1.resolve)(baseDir, modulePath);
            }
            // Dynamically import the module
            const importedModule = await import(modulePath);
            // Handle different import patterns
            if (node.names.includes('*')) {
                // import * from "module" - import entire module
                const moduleName = node.names[0] === '*' && node.names.length === 1
                    ? modulePath.split('/').pop()?.replace(/\.[^/.]+$/, '') || 'module'
                    : node.names[0];
                // Wrap the module so functions can be called with Flick syntax
                const wrappedModule = this.wrapModuleExports(importedModule);
                env.vars.set(moduleName, { value: wrappedModule, mutable: false });
            }
            else if (node.isDefaultImport) {
                // Default import: import fs from "fs"
                const name = node.names[0];
                const defaultExport = importedModule.default || importedModule;
                const wrapped = this.wrapModuleExports(defaultExport);
                env.vars.set(name, { value: wrapped, mutable: false });
            }
            else {
                // Named imports: import {readFile, writeFile} from "fs"
                for (const name of node.names) {
                    if (importedModule[name] !== undefined) {
                        const wrapped = typeof importedModule[name] === 'function'
                            ? this.wrapFunction(importedModule[name])
                            : importedModule[name];
                        env.vars.set(name, { value: wrapped, mutable: false });
                    }
                }
            }
            return null;
        }
        catch (error) {
            throw new Error(`Failed to import module ${node.from}: ${error instanceof Error ? error.message : error}`);
        }
    }
    // Wrap JS/TS functions to work with Flick's calling convention
    wrapFunction(fn) {
        return async (...args) => {
            try {
                const result = fn(...args);
                // Handle promises
                if (result && typeof result.then === 'function') {
                    return await result;
                }
                return result;
            }
            catch (error) {
                throw error;
            }
        };
    }
    // Wrap entire module exports
    wrapModuleExports(moduleExports) {
        if (typeof moduleExports === 'function') {
            return this.wrapFunction(moduleExports);
        }
        if (typeof moduleExports === 'object' && moduleExports !== null) {
            const wrapped = {};
            for (const key in moduleExports) {
                if (typeof moduleExports[key] === 'function') {
                    wrapped[key] = this.wrapFunction(moduleExports[key]);
                }
                else {
                    wrapped[key] = moduleExports[key];
                }
            }
            return wrapped;
        }
        return moduleExports;
    }
    async handleUse(node, env) {
        let modulePath;
        if (node.path) {
            // Explicit path provided
            const baseDir = (0, node_path_1.dirname)(this.currentFilePath);
            modulePath = (0, node_path_1.resolve)(baseDir, node.path);
        }
        else {
            // Infer from name (same directory, name.fk)
            const baseDir = (0, node_path_1.dirname)(this.currentFilePath);
            modulePath = (0, node_path_1.join)(baseDir, `${node.name}.fk`);
        }
        // Check if already loaded
        if (this.loadedModules.has(modulePath)) {
            const moduleExports = this.loadedModules.get(modulePath);
            env.vars.set(node.name, { value: moduleExports, mutable: false });
            return null;
        }
        // Load and parse the module
        try {
            const { Lexer } = await import('./lexer.js');
            const { Parser } = await import('./parser.js');
            const sourceCode = (0, node_fs_1.readFileSync)(modulePath, 'utf-8');
            const lexer = new Lexer(sourceCode);
            const tokens = lexer.tokenize();
            // Create a new plugin manager for the module (inherits declared plugins)
            const modulePluginManager = new plugin_js_1.PluginManager();
            // Copy plugins from current manager
            for (const [name, plugin] of this.pluginManager.plugins) {
                modulePluginManager.registerPlugin(plugin);
            }
            const parser = new Parser(tokens, modulePluginManager);
            const ast = parser.parse();
            // Create a new interpreter for the module (without running completion hooks)
            const moduleInterpreter = new Interpreter(modulePluginManager, modulePath);
            // Execute the module AST but don't run plugin completion hooks
            moduleInterpreter.programAST = ast;
            moduleInterpreter.globalEnv.__interpreter = moduleInterpreter;
            moduleInterpreter.globalEnv.__program = ast;
            for (const statement of ast.body) {
                await moduleInterpreter.evaluateStatement(statement, moduleInterpreter.globalEnv);
            }
            // Export the module's environment/program
            const moduleExports = {
                __routes: ast.body.filter((n) => n.type === 'RouteStatement'),
                __env: moduleInterpreter.globalEnv,
                __ast: ast,
            };
            this.loadedModules.set(modulePath, moduleExports);
            env.vars.set(node.name, { value: moduleExports, mutable: false });
            return null;
        }
        catch (error) {
            throw new Error(`Failed to load module ${modulePath}: ${error instanceof Error ? error.message : error}`);
        }
    }
    async handleDeclare(node, env) {
        const plugin = this.pluginManager.getPlugin(node.plugin);
        if (!plugin) {
            throw new Error(`Unknown plugin: ${node.plugin}`);
        }
        // Extract argument value if present
        let argValue = null;
        if (node.argument) {
            argValue = await this.evaluateExpression(node.argument, env);
        }
        // Register plugin built-ins
        if (plugin.registerBuiltins) {
            plugin.registerBuiltins(env, argValue);
        }
        return null;
    }
    async handleRoute(node, env) {
        // Routes are collected by the web plugin during onFileComplete
        // Just return null here
        return null;
    }
    async handleRespond(node, env) {
        const plugin = this.pluginManager.getPlugin('web');
        if (plugin?.execute) {
            return await plugin.execute(node, this, env);
        }
        return null;
    }
    defineGroup(node, env) {
        const methods = new Map();
        for (const method of node.methods) {
            methods.set(method.name, method);
        }
        this.groups.set(node.name, {
            name: node.name,
            fields: node.fields,
            methods,
            implementations: new Map(),
        });
        // Create a constructor function
        const constructor = (...args) => {
            return this.instantiateGroup(node.name, args);
        };
        env.vars.set(node.name, { value: constructor, mutable: false });
        return null;
    }
    instantiateGroup(groupName, args) {
        const groupDef = this.groups.get(groupName);
        if (!groupDef) {
            throw new Error(`Unknown group: ${groupName}`);
        }
        const instance = {
            __groupName: groupName,
            __env: { vars: new Map(), parent: this.globalEnv },
        };
        // Initialize fields
        let argIndex = 0;
        for (const field of groupDef.fields) {
            let value;
            if (field.initializer) {
                value = this.evaluateExpressionSync(field.initializer, instance.__env);
            }
            else if (argIndex < args.length) {
                value = args[argIndex++];
            }
            else {
                value = null;
            }
            instance.__env.vars.set(field.name, { value, mutable: field.mutable });
            // Also add as direct property for easier access
            Object.defineProperty(instance, field.name, {
                get: () => instance.__env.vars.get(field.name)?.value,
                set: (newValue) => {
                    const varInfo = instance.__env.vars.get(field.name);
                    if (!varInfo?.mutable) {
                        throw new Error(`Cannot reassign immutable variable: ${field.name}`);
                    }
                    instance.__env.vars.set(field.name, { value: newValue, mutable: true });
                },
                enumerable: true,
            });
        }
        // Bind methods
        for (const [methodName, methodNode] of groupDef.methods) {
            instance[methodName] = async (...args) => {
                return await this.executeTaskWithEnv(methodNode, args, instance.__env);
            };
        }
        // Bind blueprint implementations
        for (const [blueprintName, methods] of groupDef.implementations) {
            for (const [methodName, methodNode] of methods) {
                instance[methodName] = async (...args) => {
                    return await this.executeTaskWithEnv(methodNode, args, instance.__env);
                };
            }
        }
        return instance;
    }
    defineBlueprint(node, env) {
        const methods = new Map();
        for (const method of node.methods) {
            methods.set(method.name, method);
        }
        this.blueprints.set(node.name, {
            name: node.name,
            methods,
        });
        return null;
    }
    implementBlueprint(node, env) {
        const groupDef = this.groups.get(node.groupName);
        if (!groupDef) {
            throw new Error(`Unknown group: ${node.groupName}`);
        }
        const methods = new Map();
        for (const method of node.methods) {
            methods.set(method.name, method);
        }
        groupDef.implementations.set(node.blueprintName, methods);
        return null;
    }
    defineTask(node, env) {
        const task = async (...args) => {
            return await this.executeTask(node, args, env);
        };
        env.vars.set(node.name, { value: task, mutable: false });
        return null;
    }
    async executeTask(node, args, parentEnv) {
        const taskEnv = { vars: new Map(), parent: parentEnv };
        // Bind parameters
        for (let i = 0; i < node.parameters.length; i++) {
            const param = node.parameters[i];
            const value = i < args.length ? args[i] : null;
            taskEnv.vars.set(param.name, { value, mutable: true });
        }
        // Execute body
        for (const statement of node.body) {
            await this.evaluateStatement(statement, taskEnv);
        }
        return null;
    }
    async executeTaskWithEnv(node, args, instanceEnv) {
        const taskEnv = { vars: new Map(), parent: instanceEnv };
        // Bind parameters
        for (let i = 0; i < node.parameters.length; i++) {
            const param = node.parameters[i];
            const value = i < args.length ? args[i] : null;
            taskEnv.vars.set(param.name, { value, mutable: true });
        }
        // Execute body
        for (const statement of node.body) {
            await this.evaluateStatement(statement, taskEnv);
        }
        return null;
    }
    async declareVariable(node, env) {
        let value = null;
        if (node.initializer) {
            value = await this.evaluateExpression(node.initializer, env);
        }
        env.vars.set(node.name, { value, mutable: node.mutable });
        return null;
    }
    async assignVariable(node, env) {
        const value = await this.evaluateExpression(node.value, env);
        if (node.target.type === 'Identifier') {
            this.setVariable(node.target.name, value, env);
        }
        else if (node.target.type === 'MemberExpression') {
            const obj = await this.evaluateExpression(node.target.object, env);
            const prop = node.target.computed
                ? await this.evaluateExpression(node.target.property, env)
                : node.target.property.name;
            obj[prop] = value;
        }
        return value;
    }
    async executePrint(node, env) {
        const parts = [];
        for (const expr of node.expressions) {
            let value = await this.evaluateExpression(expr, env);
            // If the value is a function and the expression is just an identifier, call it with no args
            if (typeof value === 'function' && expr.type === 'Identifier') {
                value = await value();
            }
            parts.push(this.stringify(value));
        }
        const output = parts.join('');
        console.log(output);
        this.output.push(output);
        return null;
    }
    async executeIf(node, env) {
        for (const branch of node.conditions) {
            if (branch.condition === null) {
                // otherwise branch
                for (const statement of branch.body) {
                    const result = await this.evaluateStatement(statement, env);
                    // Propagate respond results
                    if (result && result.__respond) {
                        return result;
                    }
                }
                break;
            }
            else {
                const condition = await this.evaluateExpression(branch.condition, env);
                if (this.isTruthy(condition)) {
                    for (const statement of branch.body) {
                        const result = await this.evaluateStatement(statement, env);
                        // Propagate respond results
                        if (result && result.__respond) {
                            return result;
                        }
                    }
                    break;
                }
            }
        }
        return null;
    }
    async executeEachLoop(node, env) {
        const iterable = await this.evaluateExpression(node.iterable, env);
        if (!Array.isArray(iterable)) {
            throw new Error(`each loop requires an array`);
        }
        for (const item of iterable) {
            const loopEnv = { vars: new Map(), parent: env };
            loopEnv.vars.set(node.variable, { value: item, mutable: false });
            for (const statement of node.body) {
                await this.evaluateStatement(statement, loopEnv);
            }
        }
        return null;
    }
    async executeMarchLoop(node, env) {
        const start = await this.evaluateExpression(node.start, env);
        const end = await this.evaluateExpression(node.end, env);
        for (let i = start; i <= end; i++) {
            const loopEnv = { vars: new Map(), parent: env };
            loopEnv.vars.set(node.variable, { value: i, mutable: false });
            for (const statement of node.body) {
                await this.evaluateStatement(statement, loopEnv);
            }
        }
        return null;
    }
    async executeSelect(node, env) {
        const obj = await this.evaluateExpression(node.expression, env);
        for (const caseNode of node.cases) {
            if (obj.hasOwnProperty(caseNode.key)) {
                // Execute conditions if any
                let shouldExecute = true;
                for (const condition of caseNode.conditions) {
                    const result = await this.evaluateExpression(condition, env);
                    if (!this.isTruthy(result)) {
                        shouldExecute = false;
                        break;
                    }
                }
                if (shouldExecute) {
                    for (const statement of caseNode.body) {
                        await this.evaluateStatement(statement, env);
                    }
                }
            }
        }
        return null;
    }
    async evaluateBinaryExpression(node, env) {
        const left = await this.evaluateExpression(node.left, env);
        const right = await this.evaluateExpression(node.right, env);
        switch (node.operator) {
            case '+':
                // If both operands are numeric strings or numbers, do numeric addition
                const leftNum = typeof left === 'string' ? parseFloat(left) : left;
                const rightNum = typeof right === 'string' ? parseFloat(right) : right;
                if (typeof leftNum === 'number' && typeof rightNum === 'number' &&
                    !isNaN(leftNum) && !isNaN(rightNum)) {
                    return leftNum + rightNum;
                }
                // Otherwise, concatenate as strings
                return String(left) + String(right);
            case '-':
                return Number(left) - Number(right);
            case '*':
                return Number(left) * Number(right);
            case '/':
                return Number(left) / Number(right);
            case '==':
                return left === right;
            case '!=':
                return left !== right;
            case '<':
                return Number(left) < Number(right);
            case '>':
                return Number(left) > Number(right);
            case '<=':
                return Number(left) <= Number(right);
            case '>=':
                return Number(left) >= Number(right);
            default:
                throw new Error(`Unknown binary operator: ${node.operator}`);
        }
    }
    async evaluateUnaryExpression(node, env) {
        const operand = await this.evaluateExpression(node.operand, env);
        switch (node.operator) {
            case '-':
                return -operand;
            default:
                throw new Error(`Unknown unary operator: ${node.operator}`);
        }
    }
    async evaluateCall(node, env) {
        const callee = await this.evaluateExpression(node.callee, env);
        const args = [];
        for (const arg of node.args) {
            args.push(await this.evaluateExpression(arg, env));
        }
        if (typeof callee === 'function') {
            return await callee(...args);
        }
        throw new Error(`Not a function`);
    }
    async evaluateMemberExpression(node, env) {
        const obj = await this.evaluateExpression(node.object, env);
        const prop = node.computed
            ? await this.evaluateExpression(node.property, env)
            : node.property.name;
        return obj[prop];
    }
    async evaluateAsk(node, env) {
        const prompt = await this.evaluateExpression(node.prompt, env);
        return new Promise((resolve) => {
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
            });
            rl.question(this.stringify(prompt) + ' ', (answer) => {
                rl.close();
                resolve(answer);
            });
        });
    }
    lookupVariable(name, env) {
        let currentEnv = env;
        while (currentEnv) {
            if (currentEnv.vars.has(name)) {
                return currentEnv.vars.get(name).value;
            }
            currentEnv = currentEnv.parent;
        }
        throw new Error(`Undefined variable: ${name}`);
    }
    setVariable(name, value, env) {
        let currentEnv = env;
        while (currentEnv) {
            if (currentEnv.vars.has(name)) {
                const varInfo = currentEnv.vars.get(name);
                if (!varInfo.mutable) {
                    throw new Error(`Cannot reassign immutable variable: ${name}`);
                }
                currentEnv.vars.set(name, { value, mutable: true });
                return;
            }
            currentEnv = currentEnv.parent;
        }
        throw new Error(`Undefined variable: ${name}`);
    }
    isTruthy(value) {
        if (value === null || value === undefined || value === false) {
            return false;
        }
        // Empty string is falsy
        if (value === '') {
            return false;
        }
        // Empty array is falsy
        if (Array.isArray(value) && value.length === 0) {
            return false;
        }
        // Empty object is falsy
        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
            if (Object.keys(value).length === 0) {
                return false;
            }
        }
        return true;
    }
    stringify(value) {
        if (typeof value === 'string') {
            return value;
        }
        if (typeof value === 'number') {
            return value.toString();
        }
        if (typeof value === 'boolean') {
            return value ? 'yes' : 'no';
        }
        if (value === null || value === undefined) {
            return 'null';
        }
        if (Array.isArray(value)) {
            return JSON.stringify(value);
        }
        if (typeof value === 'object') {
            return JSON.stringify(value);
        }
        return String(value);
    }
    // Synchronous version for certain contexts
    evaluateExpressionSync(node, env) {
        switch (node.type) {
            case 'Literal':
                return node.value;
            case 'Identifier':
                return this.lookupVariable(node.name, env);
            case 'BinaryExpression':
                const left = this.evaluateExpressionSync(node.left, env);
                const right = this.evaluateExpressionSync(node.right, env);
                switch (node.operator) {
                    case '+': {
                        // If both operands are numeric strings or numbers, do numeric addition
                        const leftNum = typeof left === 'string' ? parseFloat(left) : left;
                        const rightNum = typeof right === 'string' ? parseFloat(right) : right;
                        if (typeof leftNum === 'number' && typeof rightNum === 'number' &&
                            !isNaN(leftNum) && !isNaN(rightNum)) {
                            return leftNum + rightNum;
                        }
                        // Otherwise, concatenate as strings
                        return String(left) + String(right);
                    }
                    case '-': return Number(left) - Number(right);
                    case '*': return Number(left) * Number(right);
                    case '/': return Number(left) / Number(right);
                    case '==': return left === right;
                    case '!=': return left !== right;
                    case '<': return Number(left) < Number(right);
                    case '>': return Number(left) > Number(right);
                    case '<=': return Number(left) <= Number(right);
                    case '>=': return Number(left) >= Number(right);
                    default:
                        throw new Error(`Unknown binary operator: ${node.operator}`);
                }
            case 'ArrayLiteral':
                return node.elements.map(elem => this.evaluateExpressionSync(elem, env));
            case 'ObjectLiteral':
                const obj = {};
                for (const prop of node.properties) {
                    obj[prop.key] = this.evaluateExpressionSync(prop.value, env);
                }
                return obj;
            case 'CallExpression':
                const callee = this.evaluateExpressionSync(node.callee, env);
                const args = node.args.map(arg => this.evaluateExpressionSync(arg, env));
                if (typeof callee === 'function') {
                    return callee(...args);
                }
                throw new Error(`Not a function`);
            default:
                throw new Error(`Cannot evaluate ${node.type} synchronously`);
        }
    }
}
exports.Interpreter = Interpreter;
//# sourceMappingURL=interpreter.js.map