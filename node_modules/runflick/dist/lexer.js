"use strict";
// Lexer for Flick language
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lexer = exports.TokenType = void 0;
var TokenType;
(function (TokenType) {
    // Keywords
    TokenType["GROUP"] = "GROUP";
    TokenType["BLUEPRINT"] = "BLUEPRINT";
    TokenType["TASK"] = "TASK";
    TokenType["FREE"] = "FREE";
    TokenType["LOCK"] = "LOCK";
    TokenType["ASSUME"] = "ASSUME";
    TokenType["MAYBE"] = "MAYBE";
    TokenType["OTHERWISE"] = "OTHERWISE";
    TokenType["EACH"] = "EACH";
    TokenType["MARCH"] = "MARCH";
    TokenType["SUPPOSE"] = "SUPPOSE";
    TokenType["OOPSIE"] = "OOPSIE";
    TokenType["ATTEMPT"] = "ATTEMPT";
    TokenType["DO"] = "DO";
    TokenType["FOR"] = "FOR";
    TokenType["WITH"] = "WITH";
    TokenType["IN"] = "IN";
    TokenType["FROM"] = "FROM";
    TokenType["TO"] = "TO";
    TokenType["WHEN"] = "WHEN";
    TokenType["SELECT"] = "SELECT";
    TokenType["END"] = "END";
    TokenType["PRINT"] = "PRINT";
    TokenType["ASK"] = "ASK";
    TokenType["AND"] = "AND";
    TokenType["YES"] = "YES";
    TokenType["NO"] = "NO";
    TokenType["NUM"] = "NUM";
    TokenType["LITERAL"] = "LITERAL";
    TokenType["DECLARE"] = "DECLARE";
    TokenType["USE"] = "USE";
    TokenType["IMPORT"] = "IMPORT";
    // Plugin-specific keywords (dynamically registered)
    TokenType["ROUTE"] = "ROUTE";
    TokenType["RESPOND"] = "RESPOND";
    // HTTP methods
    TokenType["GET"] = "GET";
    TokenType["POST"] = "POST";
    TokenType["PUT"] = "PUT";
    TokenType["DELETE"] = "DELETE";
    TokenType["PATCH"] = "PATCH";
    // Literals
    TokenType["STRING"] = "STRING";
    TokenType["NUMBER"] = "NUMBER";
    TokenType["BOOLEAN"] = "BOOLEAN";
    TokenType["IDENTIFIER"] = "IDENTIFIER";
    // Operators
    TokenType["ASSIGN"] = "ASSIGN";
    TokenType["EQUALS"] = "EQUALS";
    TokenType["NOT_EQUALS"] = "NOT_EQUALS";
    TokenType["LESS_THAN"] = "LESS_THAN";
    TokenType["GREATER_THAN"] = "GREATER_THAN";
    TokenType["LESS_EQUAL"] = "LESS_EQUAL";
    TokenType["GREATER_EQUAL"] = "GREATER_EQUAL";
    TokenType["PLUS"] = "PLUS";
    TokenType["MINUS"] = "MINUS";
    TokenType["MULTIPLY"] = "MULTIPLY";
    TokenType["DIVIDE"] = "DIVIDE";
    TokenType["DOT"] = "DOT";
    // Delimiters
    TokenType["LPAREN"] = "LPAREN";
    TokenType["RPAREN"] = "RPAREN";
    TokenType["LBRACE"] = "LBRACE";
    TokenType["RBRACE"] = "RBRACE";
    TokenType["LBRACKET"] = "LBRACKET";
    TokenType["RBRACKET"] = "RBRACKET";
    TokenType["COMMA"] = "COMMA";
    TokenType["COLON"] = "COLON";
    TokenType["ARROW"] = "ARROW";
    TokenType["AT"] = "AT";
    // Special
    TokenType["NEWLINE"] = "NEWLINE";
    TokenType["EOF"] = "EOF";
})(TokenType || (exports.TokenType = TokenType = {}));
const KEYWORDS = {
    'group': TokenType.GROUP,
    'blueprint': TokenType.BLUEPRINT,
    'task': TokenType.TASK,
    'free': TokenType.FREE,
    'lock': TokenType.LOCK,
    'assume': TokenType.ASSUME,
    'maybe': TokenType.MAYBE,
    'otherwise': TokenType.OTHERWISE,
    'each': TokenType.EACH,
    'march': TokenType.MARCH,
    'suppose': TokenType.SUPPOSE,
    'oopsie': TokenType.OOPSIE,
    'attempt': TokenType.ATTEMPT,
    'do': TokenType.DO,
    'for': TokenType.FOR,
    'with': TokenType.WITH,
    'in': TokenType.IN,
    'from': TokenType.FROM,
    'to': TokenType.TO,
    'when': TokenType.WHEN,
    'select': TokenType.SELECT,
    'end': TokenType.END,
    'print': TokenType.PRINT,
    'ask': TokenType.ASK,
    'and': TokenType.AND,
    'yes': TokenType.YES,
    'no': TokenType.NO,
    'num': TokenType.NUM,
    'literal': TokenType.LITERAL,
    'declare': TokenType.DECLARE,
    'use': TokenType.USE,
    'import': TokenType.IMPORT,
    'route': TokenType.ROUTE,
    'respond': TokenType.RESPOND,
    'GET': TokenType.GET,
    'POST': TokenType.POST,
    'PUT': TokenType.PUT,
    'DELETE': TokenType.DELETE,
    'PATCH': TokenType.PATCH,
};
class Lexer {
    input;
    position = 0;
    line = 1;
    column = 1;
    constructor(input) {
        this.input = input;
    }
    peek(offset = 0) {
        const pos = this.position + offset;
        return pos < this.input.length ? this.input[pos] : '';
    }
    advance() {
        const char = this.peek();
        this.position++;
        if (char === '\n') {
            this.line++;
            this.column = 1;
        }
        else {
            this.column++;
        }
        return char;
    }
    skipWhitespace() {
        while (this.peek() && /[ \t\r]/.test(this.peek())) {
            this.advance();
        }
    }
    skipComment() {
        if (this.peek() === '#') {
            while (this.peek() && this.peek() !== '\n') {
                this.advance();
            }
        }
    }
    readString() {
        const quote = this.advance(); // consume opening quote
        let result = '';
        while (this.peek() && this.peek() !== quote) {
            if (this.peek() === '\\') {
                this.advance();
                const next = this.advance();
                switch (next) {
                    case 'n':
                        result += '\n';
                        break;
                    case 't':
                        result += '\t';
                        break;
                    case 'r':
                        result += '\r';
                        break;
                    case '\\':
                        result += '\\';
                        break;
                    case '"':
                        result += '"';
                        break;
                    case "'":
                        result += "'";
                        break;
                    default: result += next;
                }
            }
            else {
                result += this.advance();
            }
        }
        if (this.peek() === quote) {
            this.advance(); // consume closing quote
        }
        return result;
    }
    readNumber() {
        let result = '';
        while (this.peek() && /[0-9.]/.test(this.peek())) {
            result += this.advance();
        }
        return result;
    }
    readIdentifier() {
        let result = '';
        while (this.peek() && /[a-zA-Z0-9_]/.test(this.peek())) {
            result += this.advance();
        }
        return result;
    }
    tokenize() {
        const tokens = [];
        while (this.position < this.input.length) {
            this.skipWhitespace();
            if (!this.peek())
                break;
            // Skip comments
            if (this.peek() === '#') {
                this.skipComment();
                continue;
            }
            const line = this.line;
            const column = this.column;
            // Newlines
            if (this.peek() === '\n') {
                this.advance();
                tokens.push({ type: TokenType.NEWLINE, value: '\n', line, column });
                continue;
            }
            // Strings
            if (this.peek() === '"' || this.peek() === "'") {
                const value = this.readString();
                tokens.push({ type: TokenType.STRING, value, line, column });
                continue;
            }
            // Numbers
            if (/[0-9]/.test(this.peek())) {
                const value = this.readNumber();
                tokens.push({ type: TokenType.NUMBER, value, line, column });
                continue;
            }
            // Two-character operators
            if (this.peek() === ':' && this.peek(1) === '=') {
                this.advance();
                this.advance();
                tokens.push({ type: TokenType.ASSIGN, value: ':=', line, column });
                continue;
            }
            if (this.peek() === '=' && this.peek(1) === '=') {
                this.advance();
                this.advance();
                tokens.push({ type: TokenType.EQUALS, value: '==', line, column });
                continue;
            }
            if (this.peek() === '=' && this.peek(1) === '>') {
                this.advance();
                this.advance();
                tokens.push({ type: TokenType.ARROW, value: '=>', line, column });
                continue;
            }
            if (this.peek() === '!' && this.peek(1) === '=') {
                this.advance();
                this.advance();
                tokens.push({ type: TokenType.NOT_EQUALS, value: '!=', line, column });
                continue;
            }
            if (this.peek() === '<' && this.peek(1) === '=') {
                this.advance();
                this.advance();
                tokens.push({ type: TokenType.LESS_EQUAL, value: '<=', line, column });
                continue;
            }
            if (this.peek() === '>' && this.peek(1) === '=') {
                this.advance();
                this.advance();
                tokens.push({ type: TokenType.GREATER_EQUAL, value: '>=', line, column });
                continue;
            }
            // Single-character operators and delimiters
            const char = this.peek();
            switch (char) {
                case '(':
                    this.advance();
                    tokens.push({ type: TokenType.LPAREN, value: '(', line, column });
                    continue;
                case ')':
                    this.advance();
                    tokens.push({ type: TokenType.RPAREN, value: ')', line, column });
                    continue;
                case '{':
                    this.advance();
                    tokens.push({ type: TokenType.LBRACE, value: '{', line, column });
                    continue;
                case '}':
                    this.advance();
                    tokens.push({ type: TokenType.RBRACE, value: '}', line, column });
                    continue;
                case '[':
                    this.advance();
                    tokens.push({ type: TokenType.LBRACKET, value: '[', line, column });
                    continue;
                case ']':
                    this.advance();
                    tokens.push({ type: TokenType.RBRACKET, value: ']', line, column });
                    continue;
                case ',':
                    this.advance();
                    tokens.push({ type: TokenType.COMMA, value: ',', line, column });
                    continue;
                case ':':
                    this.advance();
                    tokens.push({ type: TokenType.COLON, value: ':', line, column });
                    continue;
                case '.':
                    this.advance();
                    tokens.push({ type: TokenType.DOT, value: '.', line, column });
                    continue;
                case '+':
                    this.advance();
                    tokens.push({ type: TokenType.PLUS, value: '+', line, column });
                    continue;
                case '-':
                    this.advance();
                    tokens.push({ type: TokenType.MINUS, value: '-', line, column });
                    continue;
                case '*':
                    this.advance();
                    tokens.push({ type: TokenType.MULTIPLY, value: '*', line, column });
                    continue;
                case '/':
                    this.advance();
                    tokens.push({ type: TokenType.DIVIDE, value: '/', line, column });
                    continue;
                case '<':
                    this.advance();
                    tokens.push({ type: TokenType.LESS_THAN, value: '<', line, column });
                    continue;
                case '>':
                    this.advance();
                    tokens.push({ type: TokenType.GREATER_THAN, value: '>', line, column });
                    continue;
                case '@':
                    this.advance();
                    tokens.push({ type: TokenType.AT, value: '@', line, column });
                    continue;
                case '=':
                    // Single = (for initialization in declarations)
                    this.advance();
                    tokens.push({ type: TokenType.ASSIGN, value: '=', line, column });
                    continue;
            }
            // Identifiers and keywords
            if (/[a-zA-Z_]/.test(this.peek())) {
                const identifier = this.readIdentifier();
                const tokenType = KEYWORDS[identifier] || TokenType.IDENTIFIER;
                tokens.push({ type: tokenType, value: identifier, line, column });
                continue;
            }
            // Unknown character
            throw new Error(`Unexpected character '${this.peek()}' at line ${line}, column ${column}`);
        }
        tokens.push({ type: TokenType.EOF, value: '', line: this.line, column: this.column });
        return tokens;
    }
}
exports.Lexer = Lexer;
//# sourceMappingURL=lexer.js.map