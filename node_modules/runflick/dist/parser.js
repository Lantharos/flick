"use strict";
// Parser for Flick language
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const lexer_js_1 = require("./lexer.js");
class Parser {
    tokens;
    position = 0;
    pluginManager;
    constructor(tokens, pluginManager) {
        // Filter out newline tokens for easier parsing
        this.tokens = tokens.filter(t => t.type !== lexer_js_1.TokenType.NEWLINE);
        this.pluginManager = pluginManager;
    }
    peek(offset = 0) {
        const pos = this.position + offset;
        return pos < this.tokens.length ? this.tokens[pos] : this.tokens[this.tokens.length - 1];
    }
    advance() {
        return this.tokens[this.position++];
    }
    expect(type) {
        const token = this.peek();
        if (token.type !== type) {
            throw new Error(`Expected ${type} but got ${token.type} at line ${token.line}, column ${token.column}`);
        }
        return this.advance();
    }
    match(...types) {
        return types.includes(this.peek().type);
    }
    parse() {
        const body = [];
        // Parse declare statements first (must be at top of file)
        while (this.match(lexer_js_1.TokenType.DECLARE)) {
            body.push(this.parseDeclareStatement());
        }
        // Parse import statements (for JS/TS modules)
        while (this.match(lexer_js_1.TokenType.IMPORT)) {
            body.push(this.parseImportStatement());
        }
        // Parse use statements (imports)
        while (this.match(lexer_js_1.TokenType.USE)) {
            body.push(this.parseUseStatement());
        }
        while (!this.match(lexer_js_1.TokenType.EOF)) {
            body.push(this.parseTopLevelStatement());
        }
        return { type: 'Program', body };
    }
    parseTopLevelStatement() {
        // Check for plugin-specific statements
        if (this.match(lexer_js_1.TokenType.ROUTE)) {
            if (!this.pluginManager.isDeclared('web')) {
                throw new Error(`Feature 'route' requires declare web at top of file`);
            }
            return this.parseRouteStatement();
        }
        if (this.match(lexer_js_1.TokenType.GROUP)) {
            return this.parseGroupDeclaration();
        }
        if (this.match(lexer_js_1.TokenType.BLUEPRINT)) {
            return this.parseBlueprintDeclaration();
        }
        if (this.match(lexer_js_1.TokenType.DO)) {
            return this.parseDoImplementation();
        }
        if (this.match(lexer_js_1.TokenType.TASK)) {
            return this.parseTaskDeclaration();
        }
        if (this.match(lexer_js_1.TokenType.FREE, lexer_js_1.TokenType.LOCK)) {
            return this.parseVariableDeclaration();
        }
        return this.parseStatement();
    }
    parseDeclareStatement() {
        this.expect(lexer_js_1.TokenType.DECLARE);
        const plugin = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
        let argument;
        if (this.match(lexer_js_1.TokenType.AT)) {
            this.advance();
            // Parse the argument (could be number, string, or identifier)
            if (this.match(lexer_js_1.TokenType.NUMBER)) {
                const value = parseFloat(this.advance().value);
                argument = { type: 'Literal', value, raw: String(value) };
            }
            else if (this.match(lexer_js_1.TokenType.STRING)) {
                const value = this.advance().value;
                argument = { type: 'Literal', value, raw: value };
            }
            else if (this.match(lexer_js_1.TokenType.IDENTIFIER)) {
                // Treat identifier as a string literal (e.g., @module)
                const name = this.advance().value;
                argument = { type: 'Literal', value: name, raw: name };
            }
        }
        // Register with plugin manager
        this.pluginManager.declarePlugin(plugin, argument);
        return { type: 'DeclareStatement', plugin, argument };
    }
    parseUseStatement() {
        this.expect(lexer_js_1.TokenType.USE);
        const name = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
        let path;
        if (this.match(lexer_js_1.TokenType.STRING)) {
            path = this.advance().value;
        }
        return { type: 'UseStatement', name, path };
    }
    parseImportStatement() {
        this.expect(lexer_js_1.TokenType.IMPORT);
        const names = [];
        let alias;
        let isDefaultImport = false;
        // Handle different import patterns:
        // import fs from "fs"                    - default import
        // import {readFile, writeFile} from "fs" - named imports
        // import * from "lodash"                 - namespace import
        if (this.match(lexer_js_1.TokenType.MULTIPLY)) {
            // import * from "module"
            this.advance();
            names.push('*');
        }
        else if (this.match(lexer_js_1.TokenType.LBRACE)) {
            // import {a, b, c} from "module"
            this.advance();
            while (!this.match(lexer_js_1.TokenType.RBRACE)) {
                names.push(this.expect(lexer_js_1.TokenType.IDENTIFIER).value);
                if (this.match(lexer_js_1.TokenType.COMMA)) {
                    this.advance();
                }
            }
            this.expect(lexer_js_1.TokenType.RBRACE);
            isDefaultImport = false;
        }
        else {
            // import defaultExport from "module"
            names.push(this.expect(lexer_js_1.TokenType.IDENTIFIER).value);
            isDefaultImport = true;
        }
        this.expect(lexer_js_1.TokenType.FROM);
        const from = this.expect(lexer_js_1.TokenType.STRING).value;
        return { type: 'ImportStatement', names, from, alias, isDefaultImport };
    }
    parseRouteStatement() {
        this.expect(lexer_js_1.TokenType.ROUTE);
        // Check for HTTP method (GET, POST, etc.)
        let method;
        if (this.match(lexer_js_1.TokenType.GET, lexer_js_1.TokenType.POST, lexer_js_1.TokenType.PUT, lexer_js_1.TokenType.DELETE, lexer_js_1.TokenType.PATCH)) {
            method = this.advance().value;
        }
        const path = this.expect(lexer_js_1.TokenType.STRING).value;
        // Check for forwarding syntax: route "/auth" -> AuthRoutes
        if (this.match(lexer_js_1.TokenType.MINUS) && this.peek(1).type === lexer_js_1.TokenType.GREATER_THAN) {
            this.advance(); // consume -
            this.advance(); // consume >
            const forward = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
            return { type: 'RouteStatement', method, path, forward };
        }
        this.expect(lexer_js_1.TokenType.ARROW);
        const body = [];
        while (!this.match(lexer_js_1.TokenType.END)) {
            body.push(this.parseStatement());
        }
        this.expect(lexer_js_1.TokenType.END);
        return { type: 'RouteStatement', method, path, body };
    }
    parseGroupDeclaration() {
        this.expect(lexer_js_1.TokenType.GROUP);
        const name = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
        this.expect(lexer_js_1.TokenType.LBRACE);
        const fields = [];
        const methods = [];
        while (!this.match(lexer_js_1.TokenType.RBRACE)) {
            if (this.match(lexer_js_1.TokenType.TASK)) {
                methods.push(this.parseTaskDeclaration());
            }
            else if (this.match(lexer_js_1.TokenType.FREE, lexer_js_1.TokenType.LOCK)) {
                fields.push(this.parseVariableDeclaration());
            }
            else {
                throw new Error(`Unexpected token in group: ${this.peek().value}`);
            }
        }
        this.expect(lexer_js_1.TokenType.RBRACE);
        return { type: 'GroupDeclaration', name, fields, methods };
    }
    parseBlueprintDeclaration() {
        this.expect(lexer_js_1.TokenType.BLUEPRINT);
        const name = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
        this.expect(lexer_js_1.TokenType.LBRACE);
        const methods = [];
        while (!this.match(lexer_js_1.TokenType.RBRACE)) {
            this.expect(lexer_js_1.TokenType.TASK);
            const methodName = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
            const parameters = [];
            if (this.match(lexer_js_1.TokenType.WITH)) {
                this.advance();
                parameters.push(...this.parseParameters());
            }
            methods.push({ name: methodName, parameters });
        }
        this.expect(lexer_js_1.TokenType.RBRACE);
        return { type: 'BlueprintDeclaration', name, methods };
    }
    parseDoImplementation() {
        this.expect(lexer_js_1.TokenType.DO);
        const blueprintName = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
        this.expect(lexer_js_1.TokenType.FOR);
        const groupName = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
        this.expect(lexer_js_1.TokenType.ARROW);
        const methods = [];
        while (!this.match(lexer_js_1.TokenType.END)) {
            methods.push(this.parseTaskDeclaration());
        }
        this.expect(lexer_js_1.TokenType.END);
        return { type: 'DoImplementation', blueprintName, groupName, methods };
    }
    parseTaskDeclaration() {
        this.expect(lexer_js_1.TokenType.TASK);
        const name = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
        const parameters = [];
        if (this.match(lexer_js_1.TokenType.WITH)) {
            this.advance();
            parameters.push(...this.parseParameters());
        }
        this.expect(lexer_js_1.TokenType.ARROW);
        const body = [];
        while (!this.match(lexer_js_1.TokenType.END)) {
            body.push(this.parseStatement());
        }
        this.expect(lexer_js_1.TokenType.END);
        return { type: 'TaskDeclaration', name, parameters, body };
    }
    parseParameters() {
        const parameters = [];
        do {
            if (this.match(lexer_js_1.TokenType.COMMA)) {
                this.advance();
            }
            // Accept num, literal, or identifier as type
            let paramType;
            if (this.match(lexer_js_1.TokenType.NUM, lexer_js_1.TokenType.LITERAL, lexer_js_1.TokenType.IDENTIFIER)) {
                paramType = this.advance().value;
            }
            else {
                throw new Error(`Expected type name at line ${this.peek().line}`);
            }
            this.expect(lexer_js_1.TokenType.LPAREN);
            const name = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
            this.expect(lexer_js_1.TokenType.RPAREN);
            parameters.push({ name, paramType });
        } while (this.match(lexer_js_1.TokenType.COMMA));
        return parameters;
    }
    parseVariableDeclaration() {
        const mutable = this.match(lexer_js_1.TokenType.FREE);
        this.advance(); // consume FREE or LOCK
        let varType;
        let name;
        // Check if there's a type annotation (could be num, literal, or identifier)
        const firstToken = this.peek();
        const secondToken = this.peek(1);
        if ((this.match(lexer_js_1.TokenType.NUM, lexer_js_1.TokenType.LITERAL, lexer_js_1.TokenType.IDENTIFIER)) &&
            (secondToken.type === lexer_js_1.TokenType.IDENTIFIER)) {
            varType = this.advance().value;
            name = this.advance().value;
        }
        else {
            name = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
        }
        let initializer;
        if (this.match(lexer_js_1.TokenType.ASSIGN)) {
            this.advance();
            initializer = this.parseExpression();
        }
        else if (this.peek().type !== lexer_js_1.TokenType.RBRACE && this.peek().type !== lexer_js_1.TokenType.EOF) {
            // Allow '=' for initialization
            if (this.peek().value === '=') {
                this.advance();
                initializer = this.parseExpression();
            }
        }
        return { type: 'VariableDeclaration', name, mutable, varType, initializer };
    }
    parseStatement() {
        if (this.match(lexer_js_1.TokenType.RESPOND)) {
            if (!this.pluginManager.isDeclared('web')) {
                throw new Error(`Feature 'respond' requires declare web at top of file`);
            }
            return this.parseRespondStatement();
        }
        if (this.match(lexer_js_1.TokenType.PRINT)) {
            return this.parsePrintStatement();
        }
        if (this.match(lexer_js_1.TokenType.ASSUME)) {
            return this.parseIfStatement();
        }
        if (this.match(lexer_js_1.TokenType.EACH)) {
            return this.parseEachLoop();
        }
        if (this.match(lexer_js_1.TokenType.MARCH)) {
            return this.parseMarchLoop();
        }
        if (this.match(lexer_js_1.TokenType.SELECT)) {
            return this.parseSelectStatement();
        }
        if (this.match(lexer_js_1.TokenType.FREE, lexer_js_1.TokenType.LOCK)) {
            return this.parseVariableDeclaration();
        }
        // Check for assignment or expression statement
        const expr = this.parseExpression();
        // Check if this is an assignment
        if (this.match(lexer_js_1.TokenType.ASSIGN)) {
            this.advance();
            const value = this.parseExpression();
            return { type: 'Assignment', target: expr, value };
        }
        return { type: 'ExpressionStatement', expression: expr };
    }
    parseRespondStatement() {
        this.expect(lexer_js_1.TokenType.RESPOND);
        let content;
        let options = {};
        // Check if we have json= or just a regular expression
        if (this.match(lexer_js_1.TokenType.IDENTIFIER) && this.peek().value === 'json' && this.peek(1).type === lexer_js_1.TokenType.ASSIGN) {
            this.advance(); // consume 'json'
            this.advance(); // consume '='
            options.json = this.parseExpression();
            content = { type: 'Literal', value: '', raw: '' }; // dummy content
        }
        else {
            content = this.parseExpression();
        }
        // Check for status=
        if (this.match(lexer_js_1.TokenType.COMMA)) {
            this.advance();
            if (this.match(lexer_js_1.TokenType.IDENTIFIER) && this.peek().value === 'status' && this.peek(1).type === lexer_js_1.TokenType.ASSIGN) {
                this.advance(); // consume 'status'
                this.advance(); // consume '='
                options.status = this.parseExpression();
            }
        }
        return { type: 'RespondStatement', content, options };
    }
    parsePrintStatement() {
        this.expect(lexer_js_1.TokenType.PRINT);
        const expressions = [];
        expressions.push(this.parseExpression());
        while (this.match(lexer_js_1.TokenType.AND)) {
            this.advance();
            expressions.push(this.parseExpression());
        }
        return { type: 'PrintStatement', expressions };
    }
    parseIfStatement() {
        const conditions = [];
        // assume
        this.expect(lexer_js_1.TokenType.ASSUME);
        const assumeCondition = this.parseExpression();
        this.expect(lexer_js_1.TokenType.ARROW);
        const assumeBody = [];
        while (!this.match(lexer_js_1.TokenType.MAYBE, lexer_js_1.TokenType.OTHERWISE, lexer_js_1.TokenType.END)) {
            assumeBody.push(this.parseStatement());
        }
        conditions.push({ condition: assumeCondition, body: assumeBody });
        // maybe (elif)
        while (this.match(lexer_js_1.TokenType.MAYBE)) {
            this.advance();
            const maybeCondition = this.parseExpression();
            this.expect(lexer_js_1.TokenType.ARROW);
            const maybeBody = [];
            while (!this.match(lexer_js_1.TokenType.MAYBE, lexer_js_1.TokenType.OTHERWISE, lexer_js_1.TokenType.END)) {
                maybeBody.push(this.parseStatement());
            }
            conditions.push({ condition: maybeCondition, body: maybeBody });
        }
        // otherwise (else)
        if (this.match(lexer_js_1.TokenType.OTHERWISE)) {
            this.advance();
            this.expect(lexer_js_1.TokenType.ARROW);
            const otherwiseBody = [];
            while (!this.match(lexer_js_1.TokenType.END)) {
                otherwiseBody.push(this.parseStatement());
            }
            conditions.push({ condition: null, body: otherwiseBody });
        }
        this.expect(lexer_js_1.TokenType.END);
        return { type: 'IfStatement', conditions };
    }
    parseEachLoop() {
        this.expect(lexer_js_1.TokenType.EACH);
        const variable = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
        this.expect(lexer_js_1.TokenType.IN);
        const iterable = this.parseExpression();
        this.expect(lexer_js_1.TokenType.ARROW);
        const body = [];
        while (!this.match(lexer_js_1.TokenType.END)) {
            body.push(this.parseStatement());
        }
        this.expect(lexer_js_1.TokenType.END);
        return { type: 'EachLoop', variable, iterable, body };
    }
    parseMarchLoop() {
        this.expect(lexer_js_1.TokenType.MARCH);
        const variable = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
        this.expect(lexer_js_1.TokenType.FROM);
        const start = this.parseExpression();
        this.expect(lexer_js_1.TokenType.TO);
        const end = this.parseExpression();
        this.expect(lexer_js_1.TokenType.ARROW);
        const body = [];
        while (!this.match(lexer_js_1.TokenType.END)) {
            body.push(this.parseStatement());
        }
        this.expect(lexer_js_1.TokenType.END);
        return { type: 'MarchLoop', variable, start, end, body };
    }
    parseSelectStatement() {
        this.expect(lexer_js_1.TokenType.SELECT);
        const expression = this.parseExpression();
        this.expect(lexer_js_1.TokenType.ARROW);
        const cases = [];
        while (this.match(lexer_js_1.TokenType.WHEN)) {
            this.advance();
            const key = this.expect(lexer_js_1.TokenType.STRING).value;
            this.expect(lexer_js_1.TokenType.ARROW);
            const conditions = [];
            const body = [];
            // Check if there's a suppose statement
            if (this.match(lexer_js_1.TokenType.SUPPOSE)) {
                this.advance();
                const condition = this.parseExpression();
                this.expect(lexer_js_1.TokenType.ARROW);
                conditions.push(condition);
            }
            // Parse body until next when or end
            while (!this.match(lexer_js_1.TokenType.WHEN, lexer_js_1.TokenType.END)) {
                body.push(this.parseStatement());
            }
            cases.push({ key, conditions, body });
        }
        this.expect(lexer_js_1.TokenType.END);
        return { type: 'SelectStatement', expression, cases };
    }
    parseExpression() {
        return this.parseLogicalExpression();
    }
    parseLogicalExpression() {
        let left = this.parseComparisonExpression();
        while (this.match(lexer_js_1.TokenType.AND) && this.peek(-1).type !== lexer_js_1.TokenType.PRINT) {
            // Skip AND if it's part of print statement
            break;
        }
        return left;
    }
    parseComparisonExpression() {
        let left = this.parseAdditiveExpression();
        while (this.match(lexer_js_1.TokenType.EQUALS, lexer_js_1.TokenType.NOT_EQUALS, lexer_js_1.TokenType.LESS_THAN, lexer_js_1.TokenType.GREATER_THAN, lexer_js_1.TokenType.LESS_EQUAL, lexer_js_1.TokenType.GREATER_EQUAL)) {
            const operator = this.advance().value;
            const right = this.parseAdditiveExpression();
            left = { type: 'BinaryExpression', operator, left, right };
        }
        return left;
    }
    parseAdditiveExpression() {
        let left = this.parseMultiplicativeExpression();
        while (this.match(lexer_js_1.TokenType.PLUS, lexer_js_1.TokenType.MINUS)) {
            const operator = this.advance().value;
            const right = this.parseMultiplicativeExpression();
            left = { type: 'BinaryExpression', operator, left, right };
        }
        return left;
    }
    parseMultiplicativeExpression() {
        let left = this.parseUnaryExpression();
        while (this.match(lexer_js_1.TokenType.MULTIPLY, lexer_js_1.TokenType.DIVIDE)) {
            const operator = this.advance().value;
            const right = this.parseUnaryExpression();
            left = { type: 'BinaryExpression', operator, left, right };
        }
        return left;
    }
    parseUnaryExpression() {
        if (this.match(lexer_js_1.TokenType.MINUS)) {
            const operator = this.advance().value;
            const operand = this.parseUnaryExpression();
            return { type: 'UnaryExpression', operator, operand };
        }
        return this.parsePostfixExpression();
    }
    parsePostfixExpression() {
        let expr = this.parsePrimaryExpression();
        while (true) {
            // Check for member access: . or / followed by identifier
            if (this.match(lexer_js_1.TokenType.DOT) ||
                (this.match(lexer_js_1.TokenType.DIVIDE) && this.peek(1).type === lexer_js_1.TokenType.IDENTIFIER)) {
                this.advance();
                const property = this.expect(lexer_js_1.TokenType.IDENTIFIER).value;
                expr = {
                    type: 'MemberExpression',
                    object: expr,
                    property: { type: 'Identifier', name: property },
                    computed: false,
                };
            }
            else if (this.match(lexer_js_1.TokenType.LBRACKET)) {
                this.advance();
                const property = this.parseExpression();
                this.expect(lexer_js_1.TokenType.RBRACKET);
                expr = {
                    type: 'MemberExpression',
                    object: expr,
                    property,
                    computed: true,
                };
            }
            else if (this.match(lexer_js_1.TokenType.LPAREN) ||
                (this.match(lexer_js_1.TokenType.STRING, lexer_js_1.TokenType.NUMBER, lexer_js_1.TokenType.IDENTIFIER, lexer_js_1.TokenType.LBRACE, lexer_js_1.TokenType.LBRACKET) &&
                    (expr.type === 'Identifier' || expr.type === 'MemberExpression'))) {
                // Function call
                const args = [];
                if (this.match(lexer_js_1.TokenType.LPAREN)) {
                    this.advance();
                    while (!this.match(lexer_js_1.TokenType.RPAREN)) {
                        args.push(this.parseExpression());
                        if (this.match(lexer_js_1.TokenType.COMMA)) {
                            this.advance();
                        }
                    }
                    this.expect(lexer_js_1.TokenType.RPAREN);
                }
                else {
                    // Space-separated arguments (without parentheses)
                    // Keep parsing while we see valid argument tokens
                    // Stop at statement keywords or structural tokens
                    while (this.match(lexer_js_1.TokenType.STRING, lexer_js_1.TokenType.NUMBER, lexer_js_1.TokenType.IDENTIFIER, lexer_js_1.TokenType.LBRACE, lexer_js_1.TokenType.LBRACKET)) {
                        // Before consuming the token, check if it's a statement keyword
                        if (this.match(lexer_js_1.TokenType.FREE, lexer_js_1.TokenType.LOCK, lexer_js_1.TokenType.PRINT, lexer_js_1.TokenType.ASSUME, lexer_js_1.TokenType.EACH, lexer_js_1.TokenType.MARCH, lexer_js_1.TokenType.SELECT, lexer_js_1.TokenType.ROUTE, lexer_js_1.TokenType.RESPOND, lexer_js_1.TokenType.TASK, lexer_js_1.TokenType.GROUP, lexer_js_1.TokenType.BLUEPRINT, lexer_js_1.TokenType.DO, lexer_js_1.TokenType.DECLARE, lexer_js_1.TokenType.USE)) {
                            break;
                        }
                        // Check for structural/ending tokens BEFORE consuming
                        if (this.match(lexer_js_1.TokenType.ARROW, lexer_js_1.TokenType.ASSIGN, lexer_js_1.TokenType.EOF, lexer_js_1.TokenType.END, lexer_js_1.TokenType.MAYBE, lexer_js_1.TokenType.OTHERWISE, lexer_js_1.TokenType.RBRACE)) {
                            break;
                        }
                        // BEFORE parsing as an argument, check if this looks like a new statement
                        // An identifier followed by / or . is likely starting a new member expression, not an argument
                        if (this.match(lexer_js_1.TokenType.IDENTIFIER)) {
                            const followingToken = this.peek(1);
                            if (followingToken.type === lexer_js_1.TokenType.DIVIDE || followingToken.type === lexer_js_1.TokenType.DOT) {
                                // This identifier starts a member expression, not an argument
                                break;
                            }
                        }
                        args.push(this.parsePrimaryExpression());
                        // After parsing an arg, check if we should continue
                        if (this.match(lexer_js_1.TokenType.COMMA)) {
                            this.advance();
                            continue;
                        }
                        // Before continuing, check if the current token (which would be the next arg)
                        // is followed by a stopping point (like = in variable declarations)
                        // or if it looks like a function call (identifier followed by string/number/identifier/object/array)
                        if (this.match(lexer_js_1.TokenType.IDENTIFIER)) {
                            const followingToken = this.peek(1);
                            if (followingToken.type === lexer_js_1.TokenType.ASSIGN ||
                                followingToken.type === lexer_js_1.TokenType.ARROW ||
                                followingToken.type === lexer_js_1.TokenType.COLON) {
                                break;
                            }
                            // If identifier is followed by argument-like tokens, it's likely a function call
                            // e.g., "write "file.txt", data" should not be parsed as args to previous call
                            if (followingToken.type === lexer_js_1.TokenType.STRING ||
                                followingToken.type === lexer_js_1.TokenType.NUMBER ||
                                followingToken.type === lexer_js_1.TokenType.LBRACE ||
                                followingToken.type === lexer_js_1.TokenType.LBRACKET) {
                                break;
                            }
                        }
                        // Stop if next token is not an argument-like token
                        if (!this.match(lexer_js_1.TokenType.STRING, lexer_js_1.TokenType.NUMBER, lexer_js_1.TokenType.IDENTIFIER, lexer_js_1.TokenType.LBRACE, lexer_js_1.TokenType.LBRACKET)) {
                            break;
                        }
                    }
                }
                expr = { type: 'CallExpression', callee: expr, args };
            }
            else {
                break;
            }
        }
        return expr;
    }
    parsePrimaryExpression() {
        // String
        if (this.match(lexer_js_1.TokenType.STRING)) {
            const value = this.advance().value;
            return { type: 'Literal', value, raw: value };
        }
        // Number
        if (this.match(lexer_js_1.TokenType.NUMBER)) {
            const raw = this.advance().value;
            const value = parseFloat(raw);
            return { type: 'Literal', value, raw };
        }
        // Boolean
        if (this.match(lexer_js_1.TokenType.YES)) {
            this.advance();
            return { type: 'Literal', value: true, raw: 'yes' };
        }
        if (this.match(lexer_js_1.TokenType.NO)) {
            this.advance();
            return { type: 'Literal', value: false, raw: 'no' };
        }
        // Ask expression
        if (this.match(lexer_js_1.TokenType.ASK)) {
            this.advance();
            // Check if there's an argument for the prompt, or if we should use empty string
            let prompt;
            // If next token is a statement keyword or assignment or EOF, use empty prompt
            if (this.match(lexer_js_1.TokenType.FREE, lexer_js_1.TokenType.LOCK, lexer_js_1.TokenType.PRINT, lexer_js_1.TokenType.ASSUME, lexer_js_1.TokenType.EACH, lexer_js_1.TokenType.MARCH, lexer_js_1.TokenType.SELECT, lexer_js_1.TokenType.ROUTE, lexer_js_1.TokenType.RESPOND, lexer_js_1.TokenType.TASK, lexer_js_1.TokenType.GROUP, lexer_js_1.TokenType.BLUEPRINT, lexer_js_1.TokenType.DO, lexer_js_1.TokenType.DECLARE, lexer_js_1.TokenType.USE, lexer_js_1.TokenType.EOF, lexer_js_1.TokenType.END, lexer_js_1.TokenType.MAYBE, lexer_js_1.TokenType.OTHERWISE, lexer_js_1.TokenType.RBRACE)) {
                prompt = { type: 'Literal', value: '', raw: '' };
            }
            else {
                prompt = this.parseExpression();
            }
            return { type: 'AskExpression', prompt };
        }
        // Array literal
        if (this.match(lexer_js_1.TokenType.LBRACKET)) {
            this.advance();
            const elements = [];
            while (!this.match(lexer_js_1.TokenType.RBRACKET)) {
                elements.push(this.parseExpression());
                if (this.match(lexer_js_1.TokenType.COMMA)) {
                    this.advance();
                }
            }
            this.expect(lexer_js_1.TokenType.RBRACKET);
            return { type: 'ArrayLiteral', elements };
        }
        // Object literal
        if (this.match(lexer_js_1.TokenType.LBRACE)) {
            this.advance();
            const properties = [];
            while (!this.match(lexer_js_1.TokenType.RBRACE)) {
                const key = this.expect(lexer_js_1.TokenType.STRING).value;
                this.expect(lexer_js_1.TokenType.COLON);
                const value = this.parseExpression();
                properties.push({ key, value });
                if (this.match(lexer_js_1.TokenType.COMMA)) {
                    this.advance();
                }
            }
            this.expect(lexer_js_1.TokenType.RBRACE);
            return { type: 'ObjectLiteral', properties };
        }
        // Parenthesized expression
        if (this.match(lexer_js_1.TokenType.LPAREN)) {
            this.advance();
            const expr = this.parseExpression();
            this.expect(lexer_js_1.TokenType.RPAREN);
            return expr;
        }
        // Identifier (including type names like 'Player')
        if (this.match(lexer_js_1.TokenType.IDENTIFIER)) {
            const name = this.advance().value;
            return { type: 'Identifier', name };
        }
        throw new Error(`Unexpected token: ${this.peek().value} at line ${this.peek().line}`);
    }
}
exports.Parser = Parser;
//# sourceMappingURL=parser.js.map